package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.21 DO NOT EDIT.

import (
	"context"
	"fmt"
	"strings"
	"unicode"

	"github.com/sglauber/studiosol/graph/model"
)

const EMPTY = 0

// Verifica se a quantidade de caracteres é maior ou igual ao valor passado na API 
func equalOrGreaterThan(counter int, val int) bool {
	return counter >= val
}

func hasMinSpecialChars(s string, val int) bool {
	specialChars := "!@#$%^&*()-+\\/{}[]"
	specialCharsCount := EMPTY
	for _, letter := range s {  
			if strings.Contains(specialChars, string(letter)) {
				specialCharsCount++
			}
	}
	return equalOrGreaterThan(specialCharsCount, val)
}

func hasMinUpperCaseChars(s string, val int) bool {
	upperCaseCharsCount := EMPTY
	for _, letter := range s {
		if unicode.IsUpper(letter) {
			upperCaseCharsCount++
		}
	}
	return equalOrGreaterThan(upperCaseCharsCount, val)
}

func hasMinLowerCaseChars(s string, val int) bool {
	lowerCaseCharsCount := EMPTY
	for _, letter := range s {
		if unicode.IsLower(letter) {
			lowerCaseCharsCount++
		}
	}
	return equalOrGreaterThan(lowerCaseCharsCount, val)
}

func hasMinDigit(s string, val int) bool {
	digitCharsCount := EMPTY
	for _, letter := range s {
		if unicode.IsDigit(letter) {
			digitCharsCount++
		}
	}
	return equalOrGreaterThan(digitCharsCount, val)
}

func arrayContains(failedRules []*string, rule string) bool {
	for _, v := range failedRules {
		if *v == rule {
			return true
		}
	}
	return false
}

func (r *queryResolver) Verify(ctx context.Context, password string, rules []*model.RuleInput) (*model.CheckValidPassword, error) {

	// Array de strings para armazenar todas as regras que não passarem na verificação
	var failedRules []*string

	// Percorremos o array de regras e checamos por cada uma delas, se a regra estiver definida realizamos sua validação
	for _, rule := range rules {
		if *rule.Rule == "minSize" {
			if !equalOrGreaterThan(len(password), *rule.Value) && !arrayContains(failedRules, *rule.Rule) {
				failedRules = append(failedRules, rule.Rule)
			}
		}

		if *rule.Rule == "minSpecialChars" {
			if !hasMinSpecialChars(password, *rule.Value) && !arrayContains(failedRules, *rule.Rule){
				failedRules = append(failedRules, rule.Rule)
			}
		}

		if *rule.Rule == "minUppercase" {
			if !hasMinUpperCaseChars(password, *rule.Value) && !arrayContains(failedRules, *rule.Rule) {
				failedRules = append(failedRules, rule.Rule)
			}
		}
		
		if *rule.Rule == "minLowercase" {
			if !hasMinLowerCaseChars(password, *rule.Value) && !arrayContains(failedRules, *rule.Rule){
				failedRules = append(failedRules, rule.Rule)
			}
		}

		if *rule.Rule == "minDigit" {
			if !hasMinDigit(password, *rule.Value) && !arrayContains(failedRules, *rule.Rule) {
				failedRules = append(failedRules, rule.Rule)
			}
		}
	}

	isVerified := true
	if len(failedRules) > EMPTY {
		isVerified = false
	}

	return &model.CheckValidPassword{
		NoMatch: failedRules,
		Verify: &isVerified,
	}, nil
}

func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
